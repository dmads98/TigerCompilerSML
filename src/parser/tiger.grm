structure A = Absyn
%%
%term
    EOF
  | ID of string
  | INT of int | STRING of string
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK
  | LBRACE | RBRACE | DOT
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE | UMINUS
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF
  | BREAK | NIL
  | FUNCTION | VAR | TYPE

%nonterm  exp | program | exp_seq | exp_list | decs | mathExp

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE
	DO OF NIL

%nonassoc ASSIGN (* Associativity? *)
%right DO
%right OF
%right ELSE
%right THEN
%left OR (* Associativity? *)
%left AND (* Associativity? *)
%nonassoc EQ NEQ LT GT LE GE
%left PLUS MINUS
%left TIMES DIVIDE
%left UMINUS

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%%

program	: exp				(exp)

exp_seq : LPAREN exp_list RPAREN	() (* Assuming nesting not allowed; exp_list required? *)
exp_list : exp SEMICOLON exp_list	()
| exp					()

(* decs : *)


exp :
    (* Literals *)
    STRING				                (A.StringExp(STRING, STRINGleft))
    | ID					() (* Assuming ID is same as lvalue expr described in Tiger lang appendix *)
    | LPAREN exp RPAREN			        (exp)
    | NIL                               (A.NilExp)
    | mathExp                           (mathExp)
    (* Conditionals*)
    | IF exp THEN exp ELSE exp	        (A.IfExp({test = exp1, then' = exp2, else' = SOME(exp3), pos = IFleft}))
    | IF exp THEN exp			        (A.IfExp({test = exp1, then' = exp2, else' = NONE, pos = IFleft}))
    (* Assign, for and while -- use exp_body for BREAK *)
    | ID ASSIGN exp				        ()
    | WHILE exp DO exp	                (A.WhileExp({test = exp1, body = exp2, pos = WHILEleft}))
    | FOR ID ASSIGN exp TO exp DO exp	(A.ForExp({var = Symbol.symbol(ID), escape = ref true, lo = exp1, hi = exp2, body = exp3, pos = FORleft}))
    (* Let *)
    | LET decs IN exp_seq END		()
    | BREAK					            (A.BreakExp(BREAKleft))

mathExp:
    (* Arithmetic expressions *)
    exp PLUS exp				(A.OpExp({left = exp1, oper = A.PlusOp, right = exp2, pos = exp1left}))
    | exp MINUS exp				(A.OpExp({left = exp1, oper = A.MinusOp, right = exp2, pos = exp1left}))
    | exp TIMES exp				(A.OpExp({left = exp1, oper = A.TimesOp, right = exp2, pos = exp1left}))
    | exp DIVIDE exp			(A.OpExp({left = exp1, oper = A.DivideOp, right = exp2, pos = exp1left}))
    | MINUS exp	%prec UMINUS	(A.OpExp({A.IntExp(0), oper = A.MinusOp, right = exp, pos = expleft))
    (* Comparison *)
    | exp EQ exp				(A.OpExp({left = exp1, oper = A.EqOp, right = exp2, pos = exp1left}))
    | exp NEQ exp				(A.OpExp({left = exp1, oper = A.NeqOp, right = exp2, pos = exp1left}))
    | exp GT exp				(A.OpExp({left = exp1, oper = A.GtOp, right = exp2, pos = exp1left}))
    | exp LT exp				(A.OpExp({left = exp1, oper = A.LtOp, right = exp2, pos = exp1left}))
    | exp GE exp				(A.OpExp({left = exp1, oper = A.GeOp, right = exp2, pos = exp1left}))
    | exp LE exp				(A.OpExp({left = exp1, oper = A.LeOp, right = exp2, pos = exp1left}))
    (* Boolean Operators *)
    | exp AND exp				(A.IfExp({test = exp1, then' = exp2, else' = SOME(A.IntExp(0)), pos = exp1left}))
    | exp OR exp				(A.IfExp({test = exp1, then' = A.IntExp(1), else' = SOME(exp2), pos = exp1left}))
    | INT                       (A.IntExp(INT))



(* Q1. Do we care about differentiating/adding non-terms for
dec, type, operator, etc. e.g. See parser-2/absyn.sml


KNOWN CONFLICTS:
exp
LPAREN exp RPAREN
vs. exp_seq LPAREN exp_list RPAREN

 *)
